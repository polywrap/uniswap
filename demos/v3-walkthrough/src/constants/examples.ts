import {
  accountAbstractionUri,
  gelatoRelayUri,
  relayUri,
  safeManagerUri,
  uniswapV3Uri,
} from "./uris";
import WETH from "./inputs/WETH.json";
import USDC from "./inputs/USDC.json";
import pool from "./inputs/pool.json";
import route from "./inputs/route.json";
// import quoteCallParameters from "./inputs/quoteCallParameters.json"
import trade from "./inputs/trade.json";
import {
  BuilderConfig,
  ClientConfigBuilder,
  InvokeResult,
  IWrapPackage,
  PolywrapClient,
} from "@polywrap/client-js";
import { BigNumber, Wallet } from "ethers";
import {
  Connection,
  Connections,
  ethereumProviderPlugin,
} from "../vendor/ethereum-provider";
import { dateTimePlugin } from "@polywrap/datetime-plugin-js";

const deadline = (new Date().getTime() / 1000 + 1800).toFixed(0);

const etherUtilsWrapperUri = "wrap://ens/ethers.wraps.eth:utils@0.1.0";
const etherCoreWrapperUri = "wrap://ens/wraps.eth:ethereum@2.0.0";
const accountAbstractionWrapperUri = "wrap://ens/aa.safe.wraps.eth:core@0.1.0";
const relayerAdapterWrapperUri =
  "wrap://ens/account-abstraction.wraps.eth:relayer-adapter@0.0.1";

const saltNonce = "0x258802387238728372837283771";
const connection = {
  networkNameOrChainId: "goerli",
};

export type SimpleExample = {
  name: string;
  type: "simple";
  description: string;
  uri: string;
  method: string;
  args: Record<string, unknown>;
};

export type ComplexExample = {
  name: string;
  type: "complex";
  requiresWallet?: boolean;
  getBuilderConfig?: () => BuilderConfig;
  steps: ComplexExampleStep[];
};

export type Example = SimpleExample | ComplexExample;

export type ComplexExampleStep = {
  getDescription: (results: InvokeResult[]) => string;
  uri: string;
  method: string;
  getArgs: (results: InvokeResult[]) => Record<string, unknown>;
};

const randNumber = Math.floor(Math.random() * 101);
const storageContractAddress = "0x56535D1162011E54aa2F6B003d02Db171c17e41e";

export const examples: Record<string, Example[]> = {
  "uniswap-v3": [
    {
      name: "Get Pool Address",
      type: "simple",
      description:
        "Each Uniswap V3 Pool is uniquely identified by 3 characteristics: token-in, token-out, and fee.",
      uri: uniswapV3Uri,
      method: "getPoolAddress",
      args: {
        tokenA: WETH,
        tokenB: USDC,
        fee: "MEDIUM",
      },
    },
    {
      name: "Fetch Pool Data",
      type: "simple",
      description:
        "A Uniswap V3 Pool's on-chain state can be fetched using the pools tokens and fee, or with its address.",
      uri: uniswapV3Uri,
      method: "fetchPoolFromTokens",
      args: {
        tokenA: WETH,
        tokenB: USDC,
        fee: "MEDIUM",
        fetchTicks: false,
      },
    },
    {
      name: "Create a Route",
      type: "simple",
      description:
        "Using one or more Pools, we can create a Route to define the path of a Trade.",
      uri: uniswapV3Uri,
      method: "createRoute",
      args: {
        pools: [pool],
        inToken: WETH,
        outToken: USDC,
      },
    },
    {
      name: "Get Quote Calldata",
      type: "simple",
      description:
        "To obtain a trade quote, we can use a Route to construct calldata for Uniswap's Quoter contract",
      uri: uniswapV3Uri,
      method: "quoteCallParameters",
      args: {
        route: route,
        amount: {
          token: WETH,
          amount: "1000000000000000000", // 1 WETH
        },
        tradeType: "EXACT_INPUT",
      },
    },
    // returns transaction hash; need to add a provider.call method to ethereum wrapper
    // https://docs.ethers.org/v5/api/providers/provider/#Provider-call
    // {
    //   name: "Call the Quoter",
    //   description: "We can use the calldata generated by quoteCallParameters to call the Quoter contract directly",
    //   uri: uniswapV3Uri,
    //   method: "execCall",
    //   args: {
    //     parameters: quoteCallParameters,
    //     address: "0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6",
    //     chainId: "MAINNET",
    //     gasOptions: {
    //       gasPrice: "30000000000"
    //     }
    //   }
    // },
    {
      name: "Create a Trade",
      type: "simple",
      description:
        "We can create a Trade with the quote data returned by the Quoter contract",
      uri: uniswapV3Uri,
      method: "createUncheckedTrade",
      args: {
        swap: {
          route: route,
          inputAmount: {
            token: WETH,
            amount: "1000000000000000000", // 1 WETH
          },
          outputAmount: {
            token: USDC,
            amount: "1807237756",
          },
        },
        tradeType: "EXACT_INPUT",
      },
    },
    {
      name: "Get Swap Calldata",
      type: "simple",
      description: "We can generate calldata to execute the Trade on chain.",
      uri: uniswapV3Uri,
      method: "swapCallParameters",
      args: {
        trades: [trade],
        options: {
          slippageTolerance: "0.01",
          recipient: "0x0000000000000000000000000000000000000003",
          deadline: deadline,
        },
      },
    },
    // this will not work until we dynamically feed in the result of the call to swapCallParameters
    // {
    //   name: "Execute a Swap",
    //   description: "Let's execute the swap!",
    //   uri: uniswapV3Uri,
    //   method: "execCall",
    //   args: {
    //     parameters: swapCallParameters,
    //     address: "0xE592427A0AEce92De3Edee1F18E0157C05861564",
    //     chainId: "MAINNET",
    //     gasOptions: {
    //       gasPrice: "300000000000"
    //     }
    //   }
    // },
  ],
  "account-abstraction": [
    {
      name: "Execute Sponsored Transaction",
      type: "complex",
      requiresWallet: true,
      getBuilderConfig: () => {
        const provider = (window as any).ethereum;

        return (
          new ClientConfigBuilder()
            .addDefaults()
            .addPackages({
              "wrap://ens/wraps.eth:ethereum-provider@2.0.0":
                ethereumProviderPlugin({
                  connections: new Connections({
                    networks: {
                      goerli: new Connection({
                        provider,
                      }),
                    },
                    defaultNetwork: "goerli",
                  }),
                }) as IWrapPackage,
              "wrap://ens/datetime.polywrap.eth": dateTimePlugin(
                {}
              ) as IWrapPackage,
            })
            // .addEnv("wrap://ens/safe.wraps.eth:manager@0.1.0", {
            //   safeAddress: SAFE_ADDRESS,
            //   connection,
            // })
            .addInterfaceImplementation(
              "wrap://ens/wraps.eth:ethereum-provider@2.0.0",
              "wrap://ens/wraps.eth:ethereum-provider@2.0.0"
            )
            .addEnv(accountAbstractionWrapperUri, {
              connection,
            })
            .addEnv(relayerAdapterWrapperUri, {
              relayerApiKey: "AiaCshYRyAUzTNfZZb8LftJaAl2SS3I8YwhJJXc5J7A_",
            })
            .addRedirect(accountAbstractionWrapperUri, accountAbstractionUri)
            .addRedirect(
              etherCoreWrapperUri,
              "wrap://ipfs/QmUX4nafTqncmtucMSJGKVNB6WbEaRJLWJHMVMcZy751S9"
            )
            .addRedirect(relayerAdapterWrapperUri, relayUri)
            .addRedirect(
              "wrap://ens/gelato.wraps.eth:relayer@0.0.1",
              gelatoRelayUri
            )
            .addRedirect(
              "wrap://ens/safe.wraps.eth:manager@0.1.0",
              safeManagerUri
            ).config
        );
      },
      steps: [
        //0 encodedFunction
        {
          uri: etherUtilsWrapperUri,
          method: "encodeFunction",
          getArgs: () => {
            return {
              method: "function store(uint256 num) public",
              args: [`${randNumber}`],
            };
          },
          getDescription: () => {
            return `In this example, we will invoke the "store" function of a smart contract on address ${storageContractAddress}.
We will store a random number, in this case ${randNumber}. Refresh this page to get a new one!
In order to invoke this function, we first need to encode it.`;
          },
        },
        //1 safeAddress
        {
          uri: accountAbstractionWrapperUri,
          method: "getSafeAddress",
          getArgs: (results) => {
            return {
              config: {
                saltNonce,
              },
            };
          },
          getDescription: () => {
            return `We also need to know the address of our Safe contract.
This address is deterministic and is based on a nonce and your wallet's address. For this example, we have hard-coded a nonce, so that you always get the same address.`;
          },
        },
        // 2 relayTransaction
        {
          uri: accountAbstractionWrapperUri,
          method: "relayTransaction",
          getArgs: (results) => {
            if (!results[0].ok || !results[1].ok) {
              return {};
            }
            console.log("CESAR", results[0]);
            const metaTransactionData = {
              to: storageContractAddress,
              value: "0",
              data: results[0].value,
              operation: "0",
            };
            const gaslimitWithBuffer = BigNumber.from(300_000)
              .toString();

            const metaTransactionOptions = {
              gasLimit: gaslimitWithBuffer,
              isSponsored: true,
            };

            return {
              transaction: metaTransactionData,
              options: metaTransactionOptions,
              config: {
                saltNonce,
              },
            };
          },
          getDescription: () => {
            return `Now it's time to execute the gasless transaction!
The Account Abstraction Wrapper's relayTransaction method allows us to perform a gasless transaction by performing the following steps:
1) It checks whether there's a deployed Safe contract on your predicted address.
2) It deploys a Safe contract to the predicted address if there isn't one.
3) It executes the gasless (sponsored) transaction using the Gelato Relay.`;
          },
        },
        // 3 HTTPGet
        {
          uri: "ens/wraps.eth:http@1.1.0",
          method: "get",
          getArgs: (results) => {
            if (!results[2].ok) {
              return {};
            }
            return {
              url: `https://relay.gelato.digital/tasks/status/${results[2].value}`,
            };
          },
          getDescription: (results) => {
            if (!results[2].ok) {
              return "";
            }

            return `...And that's it!
The result of the relayTransaction call is the ID of a gasless transaction task on Gelato.
You can fetch either by running this last example, or by simply visiting:

https://relay.gelato.digital/tasks/status/${results[2].value}

Once your task is completed (taskState = "ExecSuccess") you can check the value stored in our storage contract:

https://goerli.etherscan.io/address/${storageContractAddress}#readContract

It should be your random value, unless somebody already rewrote it!
`;
          },
        },
      ],
    },
  ],
  relay: [],
  "gelato-relay": [],
  "safe-contracts": [],
  "safe-factory": [],
  "safe-manager": [],
  ethereum: [],
};
