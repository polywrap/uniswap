import {
  accountAbstractionUri,
  gelatoRelayUri,
  relayUri,
  uniswapV3Uri,
} from "./uris";
import WETH from "./inputs/WETH.json";
import USDC from "./inputs/USDC.json";
import pool from "./inputs/pool.json";
import route from "./inputs/route.json";
// import quoteCallParameters from "./inputs/quoteCallParameters.json"
import trade from "./inputs/trade.json";
import {
  BuilderConfig,
  ClientConfigBuilder,
  InvokeResult,
  IWrapPackage,
  PolywrapClient,
} from "@polywrap/client-js";
import { BigNumber, Wallet } from "ethers";
import {
  Connection,
  Connections,
  ethereumProviderPlugin,
} from "@polywrap/ethereum-provider-js";
import { dateTimePlugin } from "@polywrap/datetime-plugin-js";

const deadline = (new Date().getTime() / 1000 + 1800).toFixed(0);

const etherUtilsWrapperUri = "wrap://ens/ethers.wraps.eth:utils@0.1.0";
const etherCoreWrapperUri = "wrap://ens/wraps.eth:ethereum@2.0.0";
const accountAbstractionWrapperUri = "wrap://wrapper/account-abstraction";
const relayerAdapterWrapperUri =
  "wrap://ens/account-abstraction.wraps.eth:relayer-adapter@0.0.1";

const saltNonce = "0x258802387238728372837283782";
const connection = {
  networkNameOrChainId: "goerli",
};

export type SimpleExample = {
  name: string;
  type: "simple";
  description: string;
  uri: string;
  method: string;
  args: Record<string, unknown>;
};

export type ComplexExample = {
  name: string;
  type: "complex";
  requiresWallet?: boolean;
  getBuilderConfig?: () => BuilderConfig;
  steps: ComplexExampleStep[];
};

export type Example = SimpleExample | ComplexExample;

export type ComplexExampleStep = {
  getDescription: (results: InvokeResult[]) => string;
  uri: string;
  method: string;
  getArgs: (results: InvokeResult[]) => Record<string, unknown>;
};

export const examples: Record<string, Example[]> = {
  "uniswap-v3": [
    {
      name: "Get Pool Address",
      type: "simple",
      description:
        "Each Uniswap V3 Pool is uniquely identified by 3 characteristics: token-in, token-out, and fee.",
      uri: uniswapV3Uri,
      method: "getPoolAddress",
      args: {
        tokenA: WETH,
        tokenB: USDC,
        fee: "MEDIUM",
      },
    },
    {
      name: "Fetch Pool Data",
      type: "simple",
      description:
        "A Uniswap V3 Pool's on-chain state can be fetched using the pools tokens and fee, or with its address.",
      uri: uniswapV3Uri,
      method: "fetchPoolFromTokens",
      args: {
        tokenA: WETH,
        tokenB: USDC,
        fee: "MEDIUM",
        fetchTicks: false,
      },
    },
    {
      name: "Create a Route",
      type: "simple",
      description:
        "Using one or more Pools, we can create a Route to define the path of a Trade.",
      uri: uniswapV3Uri,
      method: "createRoute",
      args: {
        pools: [pool],
        inToken: WETH,
        outToken: USDC,
      },
    },
    {
      name: "Get Quote Calldata",
      type: "simple",
      description:
        "To obtain a trade quote, we can use a Route to construct calldata for Uniswap's Quoter contract",
      uri: uniswapV3Uri,
      method: "quoteCallParameters",
      args: {
        route: route,
        amount: {
          token: WETH,
          amount: "1000000000000000000", // 1 WETH
        },
        tradeType: "EXACT_INPUT",
      },
    },
    // returns transaction hash; need to add a provider.call method to ethereum wrapper
    // https://docs.ethers.org/v5/api/providers/provider/#Provider-call
    // {
    //   name: "Call the Quoter",
    //   description: "We can use the calldata generated by quoteCallParameters to call the Quoter contract directly",
    //   uri: uniswapV3Uri,
    //   method: "execCall",
    //   args: {
    //     parameters: quoteCallParameters,
    //     address: "0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6",
    //     chainId: "MAINNET",
    //     gasOptions: {
    //       gasPrice: "30000000000"
    //     }
    //   }
    // },
    {
      name: "Create a Trade",
      type: "simple",
      description:
        "We can create a Trade with the quote data returned by the Quoter contract",
      uri: uniswapV3Uri,
      method: "createUncheckedTrade",
      args: {
        swap: {
          route: route,
          inputAmount: {
            token: WETH,
            amount: "1000000000000000000", // 1 WETH
          },
          outputAmount: {
            token: USDC,
            amount: "1807237756",
          },
        },
        tradeType: "EXACT_INPUT",
      },
    },
    {
      name: "Get Swap Calldata",
      type: "simple",
      description: "We can generate calldata to execute the Trade on chain.",
      uri: uniswapV3Uri,
      method: "swapCallParameters",
      args: {
        trades: [trade],
        options: {
          slippageTolerance: "0.01",
          recipient: "0x0000000000000000000000000000000000000003",
          deadline: deadline,
        },
      },
    },
    // this will not work until we dynamically feed in the result of the call to swapCallParameters
    // {
    //   name: "Execute a Swap",
    //   description: "Let's execute the swap!",
    //   uri: uniswapV3Uri,
    //   method: "execCall",
    //   args: {
    //     parameters: swapCallParameters,
    //     address: "0xE592427A0AEce92De3Edee1F18E0157C05861564",
    //     chainId: "MAINNET",
    //     gasOptions: {
    //       gasPrice: "300000000000"
    //     }
    //   }
    // },
  ],
  "account-abstraction": [
    {
      name: "Test",
      type: "complex",
      steps: [
        {
          uri: "ens/wraps.eth:http@1.1.0",
          method: "get",
          getArgs: () => {
            return {
              url: "https://raw.githubusercontent.com/cbrzn/safe-playground/pileks/feat/execute-sponsored/wrap-build-artifacts/safe/factory/wrap.info",
            };
          },
          getDescription: () => {
            return "test http";
          },
        },
        {
          getArgs: () => {
            return {
              message: "Hello Polywrap!",
            };
          },
          getDescription: () => {
            return "We can write out a description here to tell people what we're doing.";
          },
          method: "info",
          uri: "ens/logger.polytest.eth",
        },
        {
          getArgs: (results) => {
            return {
              message: results[0].ok ? `${results[0].value}` : "Fail",
            };
          },
          getDescription: (results) => {
            return `Then we can use the results from all the past invokes! Stupid JSON stringify example: ${JSON.stringify(
              results[0]
            )}`;
          },
          method: "info",
          uri: "ens/logger.polytest.eth",
        },
      ],
    },
    {
      name: "Execute sponsored transaction",
      type: "complex",
      requiresWallet: true,
      getBuilderConfig: () => {
        //TODO: KEY, RPC
        const OWNER_ONE_PRIVATE_KEY =
          "0x4f3edf983ac636a65a842ce7c78d9aa706d3b113bce9c46f30d7d21715b23b1d";
        // const provider =
        //   "https://eth-goerli.g.alchemy.com/v2/xs7E_AOsOwBTRspEDnkoldxihsKveaOn";
        const SAFE_ADDRESS = "0x5655294c49e7196c21f20551330c2204db2bd670";
        const signer = new Wallet(OWNER_ONE_PRIVATE_KEY);

        const provider = (window as any).ethereum;

        return new ClientConfigBuilder()
          .addDefaults()
          .addPackages({
            "wrap://ens/wraps.eth:ethereum-provider@2.0.0":
              ethereumProviderPlugin({
                connections: new Connections({
                  networks: {
                    goerli: new Connection({
                      provider,
                    }),
                  },
                  defaultNetwork: "goerli",
                }),
              }) as IWrapPackage,
            "wrap://ens/datetime.polywrap.eth": dateTimePlugin(
              {}
            ) as IWrapPackage,
          })
          // .addEnv("wrap://ens/safe.wraps.eth:manager@0.1.0", {
          //   safeAddress: SAFE_ADDRESS,
          //   connection,
          // })
          .addInterfaceImplementation(
            "wrap://ens/wraps.eth:ethereum-provider@2.0.0",
            "wrap://ens/wraps.eth:ethereum-provider@2.0.0"
          )
          .addEnv(accountAbstractionWrapperUri, {
            connection,
          })
          .addEnv(relayerAdapterWrapperUri, {
            relayerApiKey: "AiaCshYRyAUzTNfZZb8LftJaAl2SS3I8YwhJJXc5J7A_",
          })
          .addRedirect(accountAbstractionWrapperUri, accountAbstractionUri)
          .addRedirect(
            etherCoreWrapperUri,
            "wrap://ipfs/QmUX4nafTqncmtucMSJGKVNB6WbEaRJLWJHMVMcZy751S9"
          )
          .addRedirect(relayerAdapterWrapperUri, relayUri)
          .addRedirect(
            "wrap://ens/gelato.wraps.eth:relayer@0.0.1",
            gelatoRelayUri
          ).config;
      },
      steps: [
        //0 encodedFunction
        {
          uri: etherUtilsWrapperUri,
          method: "encodeFunction",
          getArgs: () => {
            return {
              method: "function store(uint256 num) public",
              args: ["7"],
            };
          },
          getDescription: () => {
            return "First, we need to encode our function call.";
          },
        },
        //2 gasLimit
        {
          //1 safeAddress
          uri: accountAbstractionWrapperUri,
          method: "getSafeAddress",
          getArgs: (results) => {
            return {
              config: {
                saltNonce,
              },
            };
          },
          getDescription: () => {
            return "getSafeAddress";
          },
        },
        {
          uri: etherCoreWrapperUri,
          method: "estimateTransactionGas",
          getArgs: (results) => {
            if (!results[0].ok || !results[1].ok) {
              alert("Invocation failure, please try again!");
              return {};
            }
            return {
              tx: {
                to: results[1].value,
                value: "0",
                data: results[0].value,
              },
            };
          },
          getDescription: () => {
            return "Now that we have our encoded function data, we want to get an estimate the transaction gas fee.";
          },
        },
        // //2 estimation
        // {
        //   uri: relayerAdapterWrapperUri,
        //   method: "getEstimateFee",
        //   getArgs: (results) => {
        //     if (!results[1].ok) {
        //       alert("Invocation failure, please try again!");
        //       return {};
        //     }
        //     const gaslimitWithBuffer = BigNumber.from(results[1].value)
        //       .add(250_000)
        //       .toString();
        //     return {
        //       chainId: 5,
        //       gasLimit: gaslimitWithBuffer,
        //     };
        //   },
        //   getDescription: () => {
        //     return "Cesar explain";
        //   },
        // },
        //3 safeAddress
        // //4 safeBalance
        // {
        //   uri: etherCoreWrapperUri,
        //   method: "getBalance",
        //   getArgs: (results) => {
        //     return {
        //       address: results[3].ok ? results[3].value : "INVOCATION FAILURE",
        //       connection: connection,
        //     };
        //   },
        //   getDescription: (results) => {
        //     return "getBalance";
        //   },
        // },
        // //5 estimationInEth
        // {
        //   uri: etherCoreWrapperUri,
        //   method: "toEth",
        //   getArgs: (results) => {
        //     if (!results[2].ok) {
        //       alert("Invocation failure, please try again!");
        //       return {};
        //     }

        //     return {
        //       wei: results[2].value,
        //     };
        //   },
        //   getDescription: () => {
        //     return "toEth";
        //   },
        // },
        // 6 result
        {
          uri: accountAbstractionWrapperUri,
          method: "relayTransaction",
          getArgs: (results) => {
            if (!results[0].ok || !results[1].ok || !results[2].ok) {
              alert("Invocation failure, please try again!");
              return {};
            }
            console.log("CESAR", results[0]);
            const metaTransactionData = {
              to: `0x56535D1162011E54aa2F6B003d02Db171c17e41e`,
              value: "0",
              data: results[0].value,
              operation: "0",
            };
            const gaslimitWithBuffer = BigNumber.from(results[2].value)
              .add(250_000)
              .toString();

            const metaTransactionOptions = {
              gasLimit: gaslimitWithBuffer,
              isSponsored: true,
            };

            return {
              transaction: metaTransactionData,
              options: metaTransactionOptions,
              config: {
                saltNonce,
              },
            };
          },
          getDescription: () => {
            return "The AA Wrapper 1) checks whether there's a deployed Safe contract on your predicted address. 2) Deploys a Safe contract if there isn't one. 3) Executes the gasless (sponsored) transaction.";
          },
        },
        {
          uri: "ens/wraps.eth:http@1.1.0",
          method: "get",
          getArgs: (results) => {
            if (!results[3].ok) {
              alert("Invocation failure, please try again!");
              return {};
            }
            return {
              url: `https://relay.gelato.digital/tasks/status/${results[3].value}`,
            };
          },
          getDescription: () => {
            return "test http";
          },
        },
      ],
    },
  ],
  relay: [],
  "gelato-relay": [],
  "safe-contracts": [],
  "safe-factory": [],
  "safe-manager": [],
  ethereum: [],
};
